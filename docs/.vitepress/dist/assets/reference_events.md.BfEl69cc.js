import{_ as o,o as d,c as a,ag as t}from"./chunks/framework.CbQjVMS6.js";const p=JSON.parse('{"title":"Events","description":"","frontmatter":{},"headers":[],"relativePath":"reference/events.md","filePath":"reference/events.md","lastUpdated":1770414290000}'),r={name:"reference/events.md"};function c(n,e,l,i,s,u){return d(),a("div",null,[...e[0]||(e[0]=[t('<h1 id="events" tabindex="-1">Events <a class="header-anchor" href="#events" aria-label="Permalink to &quot;Events&quot;">​</a></h1><p>Core event names are emitted by <code>YukitaClient.on(event, listener)</code>.</p><h2 id="node" tabindex="-1">Node <a class="header-anchor" href="#node" aria-label="Permalink to &quot;Node&quot;">​</a></h2><ul><li><code>node.connected</code> <code>{ nodeId, resumed }</code></li><li><code>node.disconnected</code> <code>{ nodeId, code, reason }</code></li><li><code>node.error</code> <code>{ nodeId, error }</code></li><li><code>node.stats</code> <code>{ nodeId, stats }</code></li></ul><h2 id="player" tabindex="-1">Player <a class="header-anchor" href="#player" aria-label="Permalink to &quot;Player&quot;">​</a></h2><ul><li><code>player.created</code> <code>{ contextId, snapshot }</code></li><li><code>player.destroyed</code> <code>{ contextId, snapshot }</code></li><li><code>player.state</code> <code>{ contextId, snapshot, reason }</code></li></ul><h2 id="track" tabindex="-1">Track <a class="header-anchor" href="#track" aria-label="Permalink to &quot;Track&quot;">​</a></h2><ul><li><code>track.started</code> <code>{ contextId, track, nodeId }</code></li><li><code>track.ended</code> <code>{ contextId, track, reason, nodeId }</code></li><li><code>track.stuck</code> <code>{ contextId, payload, nodeId }</code></li><li><code>track.exception</code> <code>{ contextId, payload, nodeId }</code></li></ul><h2 id="queue" tabindex="-1">Queue <a class="header-anchor" href="#queue" aria-label="Permalink to &quot;Queue&quot;">​</a></h2><ul><li><code>queue.updated</code> <code>{ contextId, queue, reason }</code></li></ul><h2 id="resolve" tabindex="-1">Resolve <a class="header-anchor" href="#resolve" aria-label="Permalink to &quot;Resolve&quot;">​</a></h2><ul><li><code>resolve.completed</code> <code>{ contextId, query, output }</code></li><li><code>resolve.failed</code> <code>{ contextId, query, error }</code></li></ul><h2 id="ordering" tabindex="-1">Ordering <a class="header-anchor" href="#ordering" aria-label="Permalink to &quot;Ordering&quot;">​</a></h2><p>For the same <code>contextId</code>, events are dispatched in strict sequence:</p><ol><li>Next event waits for previous dispatch completion.</li><li>Async listener errors are isolated and reported.</li><li>Plugin event hooks run in the same ordered phase.</li></ol><p>This prevents race conditions between queue/player updates.</p>',16)])])}const v=o(r,[["render",c]]);export{p as __pageData,v as default};
